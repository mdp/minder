"use strict";(self.webpackChunkstacklok=self.webpackChunkstacklok||[]).push([[7798],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=a,f=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?r.createElement(f,o(o({ref:t},c),{},{components:n})):r.createElement(f,o({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},11330:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const i={title:"Creating a profile",sidebar_position:10},o=void 0,l={unversionedId:"how-to/create_profile",id:"how-to/create_profile",title:"Creating a profile",description:"Prerequisites",source:"@site/docs/how-to/create_profile.md",sourceDirName:"how-to",slug:"/how-to/create_profile",permalink:"/how-to/create_profile",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"Creating a profile",sidebar_position:10},sidebar:"minder",previous:{title:"Automatic Remediations",permalink:"/getting_started/remediations"},next:{title:"Manage profiles and violations",permalink:"/how-to/manage_profiles"}},s={},p=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Use a reference rule",id:"use-a-reference-rule",level:2},{value:"Write your own rule",id:"write-your-own-rule",level:2},{value:"Create a profile",id:"create-a-profile",level:2}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"minder")," CLI application"),(0,a.kt)("li",{parentName:"ul"},"A Stacklok account")),(0,a.kt)("h2",{id:"use-a-reference-rule"},"Use a reference rule"),(0,a.kt)("p",null,"The first step to creating a profile is to create the rules that your profile will apply."),(0,a.kt)("p",null,"The Minder team has provided several reference rules for common use cases. To get started quickly, create a rule from\nthe set of references."),(0,a.kt)("p",null,"Fetch all the reference rules by cloning the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/stacklok/minder-rules-and-profiles"},"minder-rules-and-profiles repository"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"git clone https://github.com/stacklok/minder-rules-and-profiles.git\n")),(0,a.kt)("p",null,"In that directory you can find all the reference rules and profiles."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"cd minder-rules-and-profiles\n")),(0,a.kt)("p",null,"Create the ",(0,a.kt)("inlineCode",{parentName:"p"},"secret_scanning")," rule type in Minder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"minder ruletype create -f rule-types/github/secret_scanning.yaml\n")),(0,a.kt)("h2",{id:"write-your-own-rule"},"Write your own rule"),(0,a.kt)("p",null,"This section describes how to write your own rule, using the existing rule ",(0,a.kt)("inlineCode",{parentName:"p"},"secret_scanning")," as a reference. If you've\nalready created the ",(0,a.kt)("inlineCode",{parentName:"p"},"secret_scanning")," rule, you may choose to skip this section."),(0,a.kt)("p",null,"Start by creating a rule that checks if secret scanning is enabled.  "),(0,a.kt)("p",null,"Create a new file called ",(0,a.kt)("inlineCode",{parentName:"p"},"secret_scanning.yaml"),"."),(0,a.kt)("p",null,"Add some basic information about the rule to the new file, such as the version, type, name, context, description and\nguidance."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"---\nversion: v1\ntype: rule-type\nname: secret_scanning\ncontext:\n  provider: github\ndescription: Verifies that secret scanning is enabled for a given repository.\n# guidance is the instructions the user will see if this rule fails\nguidance: |\n  Secret scanning is a feature that scans repositories for secrets and alerts\n  the repository owner when a secret is found. To enable this feature in GitHub,\n  you must enable it in the repository settings.\n\n  For more information, see\n  https://docs.github.com/en/github/administering-a-repository/about-secret-scanning\n")),(0,a.kt)("p",null,"Next, add the rule definition to the ",(0,a.kt)("inlineCode",{parentName:"p"},"secret_scanning.yaml")," file.\nSet ",(0,a.kt)("inlineCode",{parentName:"p"},"in_entity")," to be ",(0,a.kt)("inlineCode",{parentName:"p"},"repository"),", since secret scanning is enabled on the repository."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"def:\n  in_entity: repository\n")),(0,a.kt)("p",null,"Create a ",(0,a.kt)("inlineCode",{parentName:"p"},"rule_schema")," defining a property describing whether secret scanning is enabled on a repository."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"def:\n  # ...\n  rule_schema:\n      properties:\n        enabled:\n          type: boolean\n          default: true\n")),(0,a.kt)("p",null,"Set ",(0,a.kt)("inlineCode",{parentName:"p"},"ingest")," to make a REST call to fetch information about each registered repository and parse the response as JSON."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'def:\n  # ...\n  ingest:\n    type: rest\n    rest:\n      # This is the path to the data source. Given that this will evaluate\n      # for each repository in the organization, we use a template that\n      # will be evaluated for each repository. The structure to use is the\n      # protobuf structure for the entity that is being evaluated.\n      endpoint: "/repos/{{.Entity.Owner}}/{{.Entity.Name}}"\n      parse: json\n')),(0,a.kt)("p",null,"Configure ",(0,a.kt)("inlineCode",{parentName:"p"},"eval")," to use ",(0,a.kt)("inlineCode",{parentName:"p"},"jq")," to read the response from the REST call and determine if secret scanning is enabled."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'def:\n  # ...\n  eval:\n    type: jq\n    jq:\n      # Ingested points to the data retrieved in the `ingest` section\n      - ingested:\n          def: \'.security_and_analysis.secret_scanning.status == "enabled"\'\n        # profile points to the profile itself.\n        profile:\n          def: ".enabled"\n')),(0,a.kt)("p",null,"Set up the remediation action that will be taken if this rule is not satisfied\n(and the profile has turned on remediation). The remediation action in this case is to make a PATCH request to the\nrepository and enable secret scanning."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'def:\n  # ...\n  remediate:\n    type: rest\n    rest:\n      method: PATCH\n      endpoint: "/repos/{{.Entity.Owner}}/{{.Entity.Name}}"\n      body: |\n        { "security_and_analysis": {"secret_scanning": { "status": "enabled" } } }\n')),(0,a.kt)("p",null,"Define how users will be alerted if this rule is not satisfied. In this case a security advisory will be created in\nany repository that does not satisfy this rule."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'def:\n  # ...\n  alert:\n      type: security_advisory\n      security_advisory:\n        severity: "medium"\n')),(0,a.kt)("p",null,"Putting it all together, you get the following content in ",(0,a.kt)("inlineCode",{parentName:"p"},"secret_scanning.yaml"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'---\nversion: v1\ntype: rule-type\nname: secret_scanning\ncontext:\n  provider: github\ndescription: Verifies that secret scanning is enabled for a given repository.\nguidance: |\n  Secret scanning is a feature that scans repositories for secrets and alerts\n  the repository owner when a secret is found. To enable this feature in GitHub,\n  you must enable it in the repository settings.\n\n  For more information, see\n  https://docs.github.com/en/github/administering-a-repository/about-secret-scanning\ndef:\n  in_entity: repository\n  rule_schema:\n    properties:\n      enabled:\n        type: boolean\n        default: true\n  ingest:\n    type: rest\n    rest:\n      endpoint: "/repos/{{.Entity.Owner}}/{{.Entity.Name}}"\n      parse: json\n  eval:\n    type: jq\n    jq:\n      - ingested:\n          def: \'.security_and_analysis.secret_scanning.status == "enabled"\'\n        profile:\n          def: ".enabled"\n  remediate:\n    type: rest\n    rest:\n      method: PATCH\n      endpoint: "/repos/{{.Entity.Owner}}/{{.Entity.Name}}"\n      body: |\n        { "security_and_analysis": {"secret_scanning": { "status": "enabled" } } }\n  alert:\n    type: security_advisory\n    security_advisory:\n      severity: "medium"\n')),(0,a.kt)("p",null,"Finally, create the ",(0,a.kt)("inlineCode",{parentName:"p"},"secret_scanning")," rule in Minder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"minder ruletype create -f secret_scanning.yaml\n")),(0,a.kt)("h2",{id:"create-a-profile"},"Create a profile"),(0,a.kt)("p",null,"Now that you've created a secret scanning rule, you can set up a profile that checks if secret scanning is enabled\nin all your registered repositories."),(0,a.kt)("p",null,"Start by creating a file named ",(0,a.kt)("inlineCode",{parentName:"p"},"profile.yaml"),"."),(0,a.kt)("p",null,"Add some basic information about the profile to the new file, such as the version, type, name and context."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"version: v1\ntype: profile\nname: my-first-profile\ncontext:\n  provider: github\n")),(0,a.kt)("p",null,"Turn on alerting, so that a security advisory will be created for any registered repository that has not enabled\nsecret scanning."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'alert: "on"\n')),(0,a.kt)("p",null,"Turn on remediation, so that secret scanning will automatically be enabled for any registered repositories."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'remediate: "on"\n')),(0,a.kt)("p",null,"Register the secret scanning rule that you created in the previous step."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"repository:\n  - type: secret_scanning\n    def:\n      enabled: true\n")),(0,a.kt)("p",null,"Putting it all together, you get the following content if ",(0,a.kt)("inlineCode",{parentName:"p"},"profile.yaml"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'version: v1\ntype: profile\nname: my-first-profile\ncontext:\n  provider: github\nalert: "on"\nremediate: "on"\nrepository:\n  - type: secret_scanning\n    def:\n      enabled: true\n')),(0,a.kt)("p",null,"Finally, create your profile in Minder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"minder profile create -f profile.yaml\n")),(0,a.kt)("p",null,"Check the status of your profile and see which repositories satisfy the rules by running:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"minder profile status list --name my-first-profile --detailed\n")),(0,a.kt)("p",null,"At the moment, the ",(0,a.kt)("inlineCode",{parentName:"p"},"profile status list")," with the ",(0,a.kt)("inlineCode",{parentName:"p"},"--detailed")," flag lists all the repositories that match the rules.\nTo get a more detailed view of the profile status, use the ",(0,a.kt)("inlineCode",{parentName:"p"},"-o json")," flag to get the output in JSON format and then\nfilter the output using ",(0,a.kt)("inlineCode",{parentName:"p"},"jq"),". For example, to get all rules that pertain to the repository ",(0,a.kt)("inlineCode",{parentName:"p"},"minder")," and have failed,\nrun the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'minder profile status list --name stacklok-remediate-profile -d -ojson 2>/dev/null | jq  -C \'.ruleEvaluationStatus | map(select(.entityInfo.repo_name == "minder" and .status == "failure"))\'\n')))}d.isMDXComponent=!0}}]);